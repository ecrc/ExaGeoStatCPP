extern "C" %{
/*
 * @copyright (c) 2023     King Abdullah University of Science and Technology (KAUST).
 * @copyright (c) 2023     The Universiy of Tennessee and The Universiy of Tennessee Research Foundation.
 *                         All rights reserved.
 */

#include <runtime/parsec/ParsecHeader.h>
#include <runtime/parsec/JDFHelperFunctions.h>

static void FlmTReshape(double *apFlmT, int aM, double *apTemp, parsec_matrix_block_cyclic_t *apFlmTDesc, int aT) {

    int flmT_offset = aM * apFlmTDesc->super.mb;
    int M = (aM == apFlmTDesc->super.lmt - 1)? apFlmTDesc->super.mb - flmT_offset : apFlmTDesc->super.mb;
    if( aT-3 <= 0 ) return;
    int N = aT-3;
    int lda_flmT = apFlmTDesc->super.mb;

    // N * 1
    double *Y = apTemp;
    // N * 3
    double *X = apTemp + N;
    // 3 * 3
    double *XtX = apTemp + 4 * N;
    // 3 * 1
    double *XtY = apTemp + 4 * N + 10;
    double *phi = apTemp + 4 * N + 14;

    for(int i = 0; i < M; i++) {
        // Get Y
        for(int j = 0; j < N; j++) {
            Y[j] = apFlmT[(j+3) * lda_flmT + i];
        }

        // Get X
        for(int j = 0; j < N; j++) {
            X[3*j+0] = apFlmT[(j+2) * lda_flmT + i];
            X[3*j+1] = apFlmT[(j+1) * lda_flmT + i];
            X[3*j+2] = apFlmT[(j+0) * lda_flmT + i];
        }

        // X transpose times  X
        double alpha = 1.0;
        double beta = 0.0;

        cblas_dgemm(CblasRowMajor, CblasTrans, CblasNoTrans,
                3, 3, N,
                alpha, X, 3,
                X, 3,
                beta, XtX, 3);

        // X transpose times  y
        cblas_dgemv(CblasRowMajor, CblasTrans,
                N, 3,
                alpha, X, 3,
                Y, 1,
                beta, XtY, 1);

        // Solve
        LAPACKE_dposv(LAPACK_ROW_MAJOR, 'U', 3, 1, XtX, 3, XtY, 1);

        // Use phi to compute eps_out
        cblas_dgemv(CblasRowMajor, CblasNoTrans,
                N, 3,
                -1.0, X, 3,
                XtY, 1,
                1.0, &apFlmT[3*lda_flmT+i], lda_flmT);
    }
}


%}

/* Globals
 */
apFDataDesc       [ type = "parsec_tiled_matrix_t*" ]
apFLMDesc         [ type = "parsec_tiled_matrix_t*" aligned = apFDataDesc]
apFLMTDesc        [ type = "parsec_tiled_matrix_t*" ]
apET1Desc         [ type = "parsec_tiled_matrix_t*" ]
apET2Desc         [ type = "parsec_tiled_matrix_t*" ]
apEPDesc          [ type = "parsec_tiled_matrix_t*" ]
apSLMNDesc        [ type = "parsec_tiled_matrix_t*" ]
apIEDesc          [ type = "parsec_tiled_matrix_t*" ]
apIODesc          [ type = "parsec_tiled_matrix_t*" ]
apPDesc           [ type = "parsec_tiled_matrix_t*" ]
apDDesc           [ type = "parsec_tiled_matrix_t*" ]
apADesc           [ type = "parsec_tiled_matrix_t*" ]

aFlmTNB           [ type = "int" ]
aLSize            [ type = "int" ]
aT                [ type = "int" ]

/* Temporary buffer used for convert */
apGmtheta_r        [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]
apFmnm             [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]
apWork1            [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]
apWork2            [ type = "parsec_memory_pool_t *" hidden = on default = NULL ]

/* GPU workspace */
ws_gpu       [ type = "void *" hidden = on default = NULL ]

/* GPU number and index */
nb_cuda_devices      [ type = "int"   hidden = on default = 0 ]
cuda_device_index    [ type = "int *" hidden = on default = "NULL"]



task(m)

m = 0 .. apFLMTDesc->lmt-1
m_s = %{ return m*aFlmTNB; %}
m_e = %{ return parsec_imin((m+1)*aFlmTNB-1, apADesc->lmt-1); %}

: apFLMTDesc(m, 0)

RW apFlmT  <- apFLMTDesc(m, 0)
         -> apFLMTDesc(m, 0)


BODY
{

    double *pTemp = (double *) parsec_private_memory_pop(apWork1);
    FlmTReshape(apFlmT, m, pTemp, (parsec_matrix_block_cyclic_t *) apFLMTDesc, aT);
    parsec_private_memory_push(apWork1, pTemp);
}
END

extern "C" %{


/**
 * @return the parsec object to schedule.
 */
parsec_taskpool_t*
ForwardSHTReshape_constructor(parsec_tiled_matrix_t *apFDataDesc, parsec_tiled_matrix_t *apFLMDesc,
                              parsec_tiled_matrix_t *apFLMTDesc, parsec_tiled_matrix_t *apET1Desc,
                              parsec_tiled_matrix_t *apET2Desc, parsec_tiled_matrix_t *apEPDesc,
                              parsec_tiled_matrix_t *apSLMNDesc, parsec_tiled_matrix_t *apIEDesc,
                              parsec_tiled_matrix_t *apIODesc, parsec_tiled_matrix_t *apPDesc,
                              parsec_tiled_matrix_t *apDDesc, parsec_tiled_matrix_t *apADesc,
                              int aFDataM, int aEPN, int aET1M, int aET2M, int aPN,
                              int aFlmTNB, int aT, int aLSize)
{

    parsec_ForwardSHTReshape_taskpool_t
        *pTaskpool = parsec_ForwardSHTReshape_new(apFDataDesc, apFLMDesc, apFLMTDesc, apET1Desc, apET2Desc, apEPDesc,
                                                  apSLMNDesc, apIEDesc, apIODesc, apPDesc, apDDesc, apADesc, aFlmTNB, aLSize, aT);

    pTaskpool->_g_apGmtheta_r = (parsec_memory_pool_t*)malloc(sizeof(parsec_memory_pool_t));
    parsec_private_memory_init(pTaskpool->_g_apGmtheta_r, aFDataM * aEPN * sizeof(complex double) );

    pTaskpool->_g_apFmnm = (parsec_memory_pool_t*)malloc(sizeof(parsec_memory_pool_t));
    parsec_private_memory_init(pTaskpool->_g_apFmnm, aET1M * aEPN * sizeof(complex double) );

    pTaskpool->_g_apWork1 = (parsec_memory_pool_t*)malloc(sizeof(parsec_memory_pool_t));
    parsec_private_memory_init(pTaskpool->_g_apWork1, aET2M * aPN * sizeof(complex double) );

    pTaskpool->_g_apWork2 = (parsec_memory_pool_t*)malloc(sizeof(parsec_memory_pool_t));
    parsec_private_memory_init(pTaskpool->_g_apWork2, aET2M * aEPN * sizeof(complex double) );

#if defined(PARSEC_HAVE_DEV_CUDA_SUPPORT) || defined(PARSEC_HAVE_DEV_HIP_SUPPORT)
    int nb = 0, *dev_index;

    /** Find all CUDA devices */
    hicma_parsec_find_cuda_devices( parsec, &dev_index, &nb);

    pTaskpool->_g_ws_gpu = (void *)gb->ws;
    pTaskpool->_g_nb_cuda_devices = nb;
    pTaskpool->_g_cuda_device_index = dev_index;
#endif

    parsec_add2arena(&pTaskpool->arenas_datatypes[PARSEC_ForwardSHTReshape_DEFAULT_ADT_IDX],
                            parsec_datatype_double_t, PARSEC_MATRIX_FULL,
                            1, apFLMTDesc->mb, apFLMTDesc->nb, apFLMTDesc->mb,
                            PARSEC_ARENA_ALIGNMENT_SSE, -1);

    return (parsec_taskpool_t*) pTaskpool;
}

/**
 * @param [inout] the parsec object to destroy
*/
void ForwardSHTReshape_destructor(parsec_taskpool_t *apTaskpool)
{
    parsec_ForwardSHTReshape_taskpool_t *pTaskpool = (parsec_ForwardSHTReshape_taskpool_t *)apTaskpool;
    parsec_del2arena(&pTaskpool->arenas_datatypes[PARSEC_ForwardSHTReshape_DEFAULT_ADT_IDX]);
    parsec_private_memory_fini(pTaskpool->_g_apGmtheta_r);
    parsec_private_memory_fini(pTaskpool->_g_apFmnm);
    parsec_private_memory_fini(pTaskpool->_g_apWork1);
    parsec_private_memory_fini(pTaskpool->_g_apWork2);
    parsec_taskpool_free(apTaskpool);
}

/**
 */
int ForwardSHTReshape(parsec_context_t *apContext, int aRank, int aVerbose, parsec_tiled_matrix_t *apFDataDesc,
                      parsec_tiled_matrix_t *apFLMDesc, parsec_tiled_matrix_t *apFLMTDesc, parsec_tiled_matrix_t *apET1Desc,
                      parsec_tiled_matrix_t *apET2Desc, parsec_tiled_matrix_t *apEPDesc, parsec_tiled_matrix_t *apSLMNDesc,
                      parsec_tiled_matrix_t *apIEDesc, parsec_tiled_matrix_t *apIODesc, parsec_tiled_matrix_t *apPDesc,
                      parsec_tiled_matrix_t *apDDesc, parsec_tiled_matrix_t *apADesc, int aFDataM, int aEPN, int aET1M, int aET2M,
                      int aPN, int aFlmTNB, int aT, int aLSize, double *apNormGlobal, int aNT, int aUpperLower)
{
    parsec_taskpool_t *pTaskpool = ForwardSHTReshape_constructor(apFDataDesc, apFLMDesc, apFLMTDesc, apET1Desc, apET2Desc,
                                                                 apEPDesc, apSLMNDesc, apIEDesc, apIODesc, apPDesc, apDDesc,
                                                                 apADesc, aFDataM, aEPN, aET1M, aET2M, aPN, aFlmTNB, aT, aLSize);

    if( pTaskpool != NULL ){
        parsec_context_add_taskpool(apContext, pTaskpool);
        parsec_context_start(apContext);
        parsec_context_wait(apContext);
        ForwardSHTReshape_destructor(pTaskpool);
    }
    // Reshape
    VERBOSE_PRINT(aRank, aVerbose, ("Redistribute apFLMTDesc -> desc_A\n"));
    parsec_redistribute(apContext, apFLMTDesc, apADesc, apADesc->m, apADesc->n, 0, 0, 0, 0);

    double norm_flmT = 0.0;
    GetMatrixNorm(apContext, apNormGlobal, apFLMTDesc, aNT, aUpperLower, 0);
    norm_flmT = *apNormGlobal;
    double norm_A = 0.0;
    GetMatrixNorm(apContext, apNormGlobal, apADesc, aNT, aUpperLower, 0);
    norm_A = *apNormGlobal;

    if( 0 == aRank ) {
        fprintf(stderr, RED "norm_flmT %lf norm_A %lf\n" RESET, norm_flmT, norm_A);
    }

    // Free memory
    parsec_data_free(((parsec_matrix_block_cyclic_t *)apFLMTDesc)->mat);
    parsec_tiled_matrix_destroy((parsec_tiled_matrix_t*)apFLMTDesc);

    return 0;
}

%}
